# Dashboard de Assist√™ncia T√©cnica BonSono
# Este √© um dashboard interativo para an√°lise de dados de assist√™ncia t√©cnica dos colch√µes BonSono

import streamlit as st #cria dashboards interativos
import pandas as pd #manipula dados em tabelas
import plotly.express as px #cria gr√°ficos interativos
import plotly.graph_objects as go #cria gr√°ficos interativos avan√ßados
from plotly.subplots import make_subplots #cria subgr√°ficos
import seaborn as sns #cria gr√°ficos estat√≠sticos
import matplotlib.pyplot as plt #gera gr√°ficos est√°ticos
from datetime import datetime # manipula datas e horas

# CONFIGURA√á√ÉO DA P√ÅGINA - define como a pagina ser√° exibida 
st.set_page_config(
    page_title="Dashboard Assist√™ncia - BonSono",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS PERSONALIZADO  - variaveis de cor 
primary_color = "#003399"   # Azul BonSono
secondary_color = "#FF6B00" # Laranja 
background_color = "#F8F9FA" # Cinza claro
text_color = "#333333" # Preto suave

# CSS PERSONALIZADO - aplica o estilo ao dashboard 
# Define o estilo do dashboard com as cores e fontes escolhidas - INJETA html/css diretamente no Streamlit
st.markdown(f"""
    <style>
    .stApp {{
        background-color: {background_color};
        font-family: 'Segoe UI', sans-serif;
    }}
    .css-1d391kg p {{
        color: {text_color};
    }}
    h1, h2, h3, h4 {{
        color: {primary_color} !important;
    }}
    .stButton>button {{
        background-color: {primary_color};
        color: white;
        border-radius: 8px;
        border: none;
    }}
    .stButton>button:hover {{
        background-color: #002277;
    }}
    .metric-container {{
        text-align: center;
        padding: 15px;
        border-radius: 10px;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 10px;
        color: {text_color};
    }}
    .metric-value {{
        font-size: 24px;
        font-weight: bold;
        color: {primary_color};
    }}
    .metric-label {{
        font-size: 14px;
        color: #666;
    }}
    </style>
""", unsafe_allow_html=True)

# LOGO E T√çTULO - divide a tela em 2 colunas com propor√ß√£o 1:3
col1, col2 = st.columns([1, 3])
with col1:
    try:
        st.image("logo-bonsono.png.webp", width=200)
    except:
        st.write("<div style='font-size:12px;color:#666'>Logo BonSono</div>", unsafe_allow_html=True)
with col2:
    st.markdown(f"""
    <h1 style='color: {primary_color}; margin: 0;'>üìä Dashboard de Assist√™ncia T√©cnica</h1>
    <p style='color: {text_color}; font-size: 16px;'>Colch√µes BonSono | Relat√≥rio: 02 de Maio a 28 de Agosto de 2025</p>
    """, unsafe_allow_html=True)

# CARREGAMENTO DE DADOS (CORRIGIDO) 
@st.cache_data # Armazena os dados em cache para melhorar a performance
def load_data():
    try:
        # Tenta carregar o arquivo
        df = pd.read_excel("RelatorioCompleto.xlsx")  #ler o arquivo Excel
        st.write("‚úÖ Excel carregado com sucesso!")
        
        # Limpar nomes das colunas
        df.columns = df.columns.str.strip()
        
        # Converter 'Data Chamada' com formato expl√≠cito - dd/mm/yyyy HH:MM:SS
        df['Data Chamada'] = pd.to_datetime(df['Data Chamada'], format='%d/%m/%Y %H:%M:%S', errors='coerce')
        
        # Remover linhas onde a data √© inv√°lida (NaT)
        if df['Data Chamada'].isna().all():
            st.error("‚ùå Todas as datas est√£o inv√°lidas. Verifique a coluna 'Data Chamada' no Excel.")
            st.stop()
            
        df = df.dropna(subset=['Data Chamada'])
        
        # Criar coluna 'Data' como date
        df['Data'] = df['Data Chamada'].dt.date
        
        return df

    except FileNotFoundError:
        st.error("‚ùå Arquivo 'relatorio.xlsx' n√£o encontrado. Verifique se est√° na pasta correta.")
        st.info("üìÅ A pasta deve conter: `app.py`, `relatorio.xlsx` e `logo-bonsono.png.webp`")
        st.stop()
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar dados: {e}")
        st.stop()

# Carregar dados
df = load_data()

#  FILTROS SIDEBAR - filtros laterais
st.sidebar.header("üîç Filtros")

# Garantir que h√° dados para filtrar
if len(df) == 0:
    st.warning("‚ö†Ô∏è Nenhum dado v√°lido para exibir.")
    st.stop()

data_min = df['Data'].min()
data_max = df['Data'].max()

#Cabe√ßalhos dos filtros
date_range = st.sidebar.date_input(
    label="Selecione o per√≠odo",
    value=[data_min, data_max],
    min_value=data_min,
    max_value=data_max
)
#Cria um dropdown para selecionar vendedores
vendedor_filter = st.sidebar.multiselect(
    "Vendedor",
    options=df['VENDEDOR'].dropna().unique(),
    default=[]
)

grupo_filter = st.sidebar.multiselect(
    "Grupo",
    options=df['GRUPO'].dropna().unique(),
    default=[]
)

# Aplicar filtros
filtered_df = df.copy()
filtered_df = filtered_df[
    (filtered_df['Data'] >= date_range[0]) &
    (filtered_df['Data'] <= date_range[1])
]

if vendedor_filter:
    filtered_df = filtered_df[filtered_df['VENDEDOR'].isin(vendedor_filter)]
if grupo_filter:
    filtered_df = filtered_df[filtered_df['GRUPO'].isin(grupo_filter)]

if len(filtered_df) == 0:
    st.warning("‚ö†Ô∏è Nenhum dado encontrado com os filtros aplicados.")
    st.stop()

#  M√âTRICAS GERAIS 
st.markdown("### üìà M√©tricas Gerais")
col1, col2, col3, col4 = st.columns(4) #4 colunas para as m√©tricas

total_atendimentos = len(filtered_df)
valor_total = filtered_df['TOTAL'].sum()
ticket_medio = valor_total / total_atendimentos if total_atendimentos > 0 else 0
produtos_unicos = filtered_df['PRODUTO'].nunique()

# 4 colunas para exibir os cards
col1.markdown(f"<div class='metric-container'><div class='metric-value'>{total_atendimentos}</div><div class='metric-label'>Atendimentos</div></div>", unsafe_allow_html=True)
col2.markdown(f"<div class='metric-container'><div class='metric-value'>R$ {valor_total:,.2f}</div><div class='metric-label'>Valor Total</div></div>", unsafe_allow_html=True)
col3.markdown(f"<div class='metric-container'><div class='metric-value'>R$ {ticket_medio:,.2f}</div><div class='metric-label'>Ticket M√©dio</div></div>", unsafe_allow_html=True)
col4.markdown(f"<div class='metric-container'><div class='metric-value'>{produtos_unicos}</div><div class='metric-label'>Produtos √önicos</div></div>", unsafe_allow_html=True)

# === GR√ÅFICOS INTERATIVOS ===

# 1. Mapa de Calor: Defeitos por Produto
st.markdown("### üî• Mapa de Calor: Defeitos por Produto")
heatmap_data = pd.crosstab(filtered_df['PRODUTO'], filtered_df['Motivo Constatado'])
if not heatmap_data.empty:
    fig_heatmap = px.imshow(
        heatmap_data,
        text_auto=True,
        aspect="auto",
        color_continuous_scale="Blues",
        labels=dict(x="Motivo", y="Produto", color="Quantidade")
    )
    fig_heatmap.update_layout(
        title="Frequ√™ncia de Defeitos por Produto",
        xaxis_title="Motivo Constatado",
        yaxis_title="Produto",
        height=600
    )
    st.plotly_chart(fig_heatmap, use_container_width=True)
else:
    st.info("Nenhum dado dispon√≠vel para o mapa de calor.")

# 2. Produtos Mais Atendidos
st.markdown("### üèÜ Produtos Mais Atendidos")
prod_count = filtered_df['PRODUTO'].value_counts().reset_index()
prod_count.columns = ['PRODUTO', 'Contagem']
fig_prod = px.bar(
    prod_count,
    x='Contagem',
    y='PRODUTO',
    orientation='h',
    color='Contagem',
    color_continuous_scale='Blues',
    labels={'Contagem': 'Quantidade', 'PRODUTO': 'Produto'},
    hover_data={'PRODUTO': True, 'Contagem': True}
)
fig_prod.update_layout(
    title="Quantidade de Atendimentos por Produto",
    yaxis={'categoryorder': 'total ascending'},
    height=500
)
st.plotly_chart(fig_prod, use_container_width=True)

# 3. Distribui√ß√£o de Defeitos (Pizza)
st.markdown("### Distribui√ß√£o de Motivos de Defeito")

defeito_count = filtered_df['Motivo Constatado'].value_counts().reset_index()
defeito_count.columns = ['Motivo', 'Quantidade']

# Paleta de azul personalizada para a empresa BonSono
cores_azul = [
    "#003399",   # Azul BonSono
    "#0052b3",
    "#0078d4",
    "#00a6ed",
    "#80cfff"
]

fig_defeito = px.pie(
    defeito_count,
    names='Motivo',
    values='Quantidade',
    color_discrete_sequence=cores_azul,
    hole=0.4
)

# Mostrar percentual dentro e nome na legenda
fig_defeito.update_traces(
    textinfo='percent',
    textposition='inside'
)

# Layout mais limpo com legenda ao lado
fig_defeito.update_layout(
    title="Distribui√ß√£o de Motivos de Defeito",
    legend_title="Motivo",
    legend=dict(
        orientation="v",
        y=1,
        x=1.05
    ),
    height=600,
    width=900
)

st.plotly_chart(fig_defeito, use_container_width=True)

# 4. Evolu√ß√£o Di√°ria de Atendimentos
st.markdown("### üìÖ Evolu√ß√£o Di√°ria de Atendimentos")

# Agrupar por data
daily = filtered_df.groupby('Data').size().reset_index(name='Quantidade')

# Converter 'Data' para string no formato dd/mm/yyyy
daily['Data'] = pd.to_datetime(daily['Data']).dt.strftime('%d/%m/%Y')

# Criar gr√°fico
fig_daily = px.line(
    daily,
    x='Data',
    y='Quantidade',
    markers=True,
    line_shape='spline',
    color_discrete_sequence=[primary_color]
)

# Atualizar estilo DA LINHA ANTES de exibir
fig_daily.update_traces(line=dict(width=3))

# Atualizar layout
fig_daily.update_layout(
    title="Quantidade de Atendimentos por Dia",
    xaxis_title="Data",
    yaxis_title="Atendimentos",
    hovermode="x unified"
)

# Exibir gr√°fico
st.plotly_chart(fig_daily, use_container_width=True)

# 5. Valor Total por Vendedor
st.markdown("### üíº Valor Total por Vendedor")
vendedor_valor = filtered_df.groupby('VENDEDOR')['TOTAL'].sum().reset_index().sort_values('TOTAL', ascending=False)
fig_vendedor = px.bar(
    vendedor_valor,
    x='TOTAL',
    y='VENDEDOR',
    orientation='h',
    color='TOTAL',
    color_continuous_scale='Blues',
    labels={'TOTAL': 'Valor (R$)', 'VENDEDOR': 'Vendedor'}
)
fig_vendedor.update_layout(
    title="Valor Total de Atendimentos por Vendedor",
    height=400
)
st.plotly_chart(fig_vendedor, use_container_width=True)

# === TABELA DETALHADA - EXCEL ===
st.markdown("### üìÑ Dados Detalhados")
columns_to_show = ['NUNOTA', 'Parceiro', 'PRODUTO', 'Motivo Constatado', 'GRUPO', 'VENDEDOR', 'TOTAL', 'Data']
st.dataframe(
    filtered_df[columns_to_show].sort_values('Data', ascending=False),
    use_container_width=True,
    hide_index=True,
    height=400
)
# --- P√ÅGINA: PREVIS√ÉO DE DEFEITOS ---
st.markdown("---")
st.markdown("## üîÆ Previs√£o de Defeitos")

st.write("""
Selecione os dados do produto para prever o defeito mais prov√°vel com base em hist√≥rico.
""")

# Criar c√≥pia segura do df
df_pred = df.copy()

# Garantir que n√£o h√° valores nulos em colunas cr√≠ticas
df_pred = df_pred.dropna(subset=['PRODUTO', 'GRUPO', 'VALOR_UNITARIO', 'Motivo Constatado'])

# Limpar motivos muito longos ou compostos
df_pred['Motivo Constatado'] = df_pred['Motivo Constatado'].astype(str) #converte para string
df_pred = df_pred[~df_pred['Motivo Constatado'].str.contains("AUTORIZADA", na=False)] #remove linhas com "AUTORIZADA"
df_pred = df_pred[df_pred['Motivo Constatado'] != 'nan'] #remove linhas com 'nan'

# Verificar quantidade de dados
if len(df_pred) < 5:
    st.warning("‚ùå Poucos dados para treinar o modelo. Atualmente: " + str(len(df_pred)) + " registros v√°lidos.") #verifica se h√° poucos dados
else:
    try:
        # Importa o modelo de IA "Random Forest" (Floresta Aleat√≥ria), usado para prever qual defeito √© mais prov√°vel com base nos dados hist√≥ricos
        from sklearn.ensemble import RandomForestClassifier
        # Converte textos (como nomes de produtos ou vendedores) em n√∫meros, porque modelos de IA s√≥ trabalham com n√∫meros
        from sklearn.preprocessing import LabelEncoder
        # Divide os dados em conjuntos de treino e teste, para treinar o modelo e depois testar sua precis√£o - 80% treino e 20% teste
        from sklearn.model_selection import train_test_split

        # Selecionar colunas
        features = ['PRODUTO', 'GRUPO']
        target = 'Motivo Constatado'

        df_model = df_pred[features + [target]].dropna()

        # Verificar se h√° pelo menos 2 tipos diferentes de defeitos - Se todos os registros forem do mesmo defeito, o modelo n√£o pode "aprender a diferenciar
        if df_model[target].nunique() < 2:
            st.warning("‚ùå √â necess√°rio ter pelo menos 2 tipos diferentes de defeitos para treinar o modelo.")
        else:
            # Codificar vari√°veis categ√≥ricas
            le_produto = LabelEncoder()
            le_grupo = LabelEncoder()
            le_motivo = LabelEncoder()

            df_model['PRODUTO'] = le_produto.fit_transform(df_model['PRODUTO']) # transforma os nomes dos produtos em n√∫meros
            df_model['GRUPO'] = le_grupo.fit_transform(df_model['GRUPO']) # transforma os grupos (regi√µes) em n√∫meros
            df_model['Motivo'] = le_motivo.fit_transform(df_model['Motivo Constatado']) # transforma os motivos de defeito em n√∫meros

            X = df_model[['PRODUTO', 'GRUPO']] # Seleciona as colunas de entrada
            y = df_model['Motivo'] # Seleciona a coluna de sa√≠da (o que queremos prever)

            # Dividir dados com seguran√ßa - treino e teste
            # Se houver poucos dados, usa 20% para teste, mas garante que n√£o seja maior que 50% do total
            test_size = min(0.2, 0.5) # 20% para teste, mas n√£o mais que 50% do total
            if len(X) > 1:
                # Evitar erro de stratify com classes pequenas
                if y.nunique() < 2:
                 st.warning("‚ùå √â necess√°rio ter pelo menos 2 tipos diferentes de defeitos para treinar o modelo.")
                else:
                  if (y.value_counts() < 2).any():
                    st.warning("‚ö†Ô∏è Algum defeito tem apenas 1 registro. Treinando sem estratifica√ß√£o.")
                    X_train, X_test, y_train, y_test = train_test_split(
                   X, y, test_size=test_size, random_state=42
                   )
                  else:
                    X_train, X_test, y_train, y_test = train_test_split(
                     X, y, test_size=test_size, random_state=42, stratify=y
        )
            else:
                X_train, X_test, y_train, y_test = X, pd.DataFrame(), y, pd.Series()

            # Treinar modelo - algoritmo de Floresta Aleat√≥ria
            model = RandomForestClassifier(n_estimators=50, random_state=42, min_samples_split=2, min_samples_leaf=1)
            model.fit(X_train, y_train)

            # Mostrar acur√°cia se houver dados de teste
            if len(X_test) > 0:
                accuracy = model.score(X_test, y_test)
                st.success(f"üéØ Modelo treinado! Acur√°cia: {accuracy:.2f}")
            else:
                st.success("üéØ Modelo treinado com todos os dados (sem teste)")

            # Formul√°rio de entrada
            st.markdown("### üìù Insira os dados para previs√£o")

            produto_input = st.selectbox("Produto", options=le_produto.classes_)
            grupo_input = st.selectbox("Grupo (Regi√£o)", options=le_grupo.classes_)
    
            if st.button("üîç Prever Defeito"):
                # Codificar entradas
                prod_cod = le_produto.transform([produto_input])[0]
                grupo_cod = le_grupo.transform([grupo_input])[0]

                # Fazer previs√£o
                pred = model.predict([[prod_cod, grupo_cod]])[0]
                proba = model.predict_proba([[prod_cod, grupo_cod]])[0]
                motivo_predito = le_motivo.inverse_transform([pred])[0]

                # Confian√ßa
                confianca = max(proba) * 100

                # Exibir resultado
                st.markdown(f"""
                ### ‚úÖ Previs√£o de Defeito
                - **Defeito mais prov√°vel:** `{motivo_predito}`
                - **Confian√ßa da previs√£o:** `{confianca:.1f}%`
                """)

                # Mostrar detalhes
                with st.expander("Ver detalhes da previs√£o"):
                    probs = pd.DataFrame({
                        'Motivo': le_motivo.classes_,
                        'Probabilidade (%)': proba * 100
                    }).sort_values('Probabilidade (%)', ascending=False)
                    st.dataframe(probs)
    except Exception as e:
        st.error(f"‚ùå Erro ao treinar modelo: {str(e)}")
        st.info("üí° Isso pode acontecer se houver pouca varia√ß√£o nos tipos de defeito.")

    #  P√ÅGINA: LEAN SIX SIGMA (DMAIC)
st.markdown("---")
st.markdown("## üß© Lean Six Sigma: DMAIC")

st.write("""
Este m√≥dulo aplica a metodologia DMAIC para an√°lise e melhoria cont√≠nua com base nos dados de assist√™ncia t√©cnica.
""")

# Carregar dados para esta aba
df_dmaic = df.copy()

# === 1. DEFINE (Definir o Problema) ===
st.markdown("### üîç 1. Define: Definir o Problema")

# Passo 1: Encontrar o par (Produto, Motivo) com mais ocorr√™ncias
contagem_defeitos = df_dmaic.groupby(['PRODUTO', 'Motivo Constatado']).size().reset_index(name='Contagem')
top_row = contagem_defeitos.loc[contagem_defeitos['Contagem'].idxmax()]

produto_prioritario = top_row['PRODUTO']
motivo_prioritario = top_row['Motivo Constatado']
frequencia = top_row['Contagem']

# Passo 2: Encontrar a regi√£o (GRUPO) onde esse produto tem mais defeitos
df_grupo = df_dmaic[df_dmaic['PRODUTO'] == produto_prioritario]
grupo_prioritario = df_grupo['GRUPO'].value_counts().index[0] if not df_grupo.empty else "N√£o dispon√≠vel"

# Passo 3: Exibir o problema priorit√°rio com base nos dados
st.write(f"""
**Problema Priorit√°rio:**  
O defeito mais cr√≠tico √© **'{motivo_prioritario}'** no produto **'{produto_prioritario}'**, com **{frequencia} ocorr√™ncias**, principalmente na regi√£o **'{grupo_prioritario}'**.

**Declara√ß√£o do Problema:**  
"O produto **{produto_prioritario}** apresenta alto √≠ndice de **'{motivo_prioritario}'** na regi√£o **{grupo_prioritario}**, gerando retrabalho, custos elevados e insatisfa√ß√£o do cliente."
""")

# Campo para o usu√°rio escrever seu problema (com valor sugerido)
st.text_area(
    "üìù Descreva o problema (opcional)",
    value=f"Reduzir o √≠ndice de '{motivo_prioritario}' no produto '{produto_prioritario}'",
    height=100
)
# === TOP 5 COMBINA√á√ïES PRODUTO √ó DEFEITO ===
st.markdown("### üîù Top 5 Combina√ß√µes Produto √ó Defeito")
st.write("As combina√ß√µes de produto e defeito com maior frequ√™ncia no per√≠odo selecionado:")

# Mostrar tabela com top 5
contagem_defeitos = df_dmaic.groupby(['PRODUTO', 'Motivo Constatado']).size().reset_index(name='Contagem')
top_5 = contagem_defeitos.sort_values('Contagem', ascending=False).head(5)

# Formatar colunas para melhor visualiza√ß√£o
st.dataframe(
    top_5,
    use_container_width=True,
    hide_index=True
)

# === 2. MEASURE (Medir) ===
st.markdown("### üìè 2. Measure: Medir o Problema")

# M√©tricas-chave
total_defeitos = len(df_dmaic)
defeitos_prioritarios = len(df_dmaic[df_dmaic['Motivo Constatado'] == motivo_prioritario])
taxa_defeito = (defeitos_prioritarios / total_defeitos) * 100

# Mostrar m√©tricas
col1, col2, col3 = st.columns(3)
col1.metric("Total de Defeitos", total_defeitos)
col2.metric(f"Defeitos '{motivo_prioritario}'", defeitos_prioritarios)
col3.metric("Taxa de Ocorr√™ncia", f"{taxa_defeito:.1f}%")

# Gr√°fico de evolu√ß√£o
st.markdown(f"**Evolu√ß√£o de '{motivo_prioritario}' ao longo do m√™s**")
daily_top = df_dmaic[df_dmaic['Motivo Constatado'] == motivo_prioritario].groupby('Data').size().reset_index(name='Quantidade')
daily_top['Data'] = pd.to_datetime(daily_top['Data']).dt.strftime('%d/%m')
fig_measure = px.line(daily_top, x='Data', y='Quantidade', markers=True)
fig_measure.update_layout(title=f"Defeitos de '{motivo_prioritario}' por Dia", yaxis_title="Quantidade")
st.plotly_chart(fig_measure, use_container_width=True)

# === 3. ANALYZE (Analisar Causa Raiz) ===
st.markdown("### üß† 3. Analyze: Analisar Causa Raiz")

# Gr√°fico de Pareto
st.markdown("#### üìä Diagrama de Pareto")
defeitos = df_dmaic['Motivo Constatado'].value_counts().reset_index()
defeitos.columns = ['Motivo', 'Frequ√™ncia']
defeitos['Acumulado %'] = (defeitos['Frequ√™ncia'].cumsum() / defeitos['Frequ√™ncia'].sum()) * 100

fig_pareto = go.Figure()
fig_pareto.add_trace(go.Bar(
    x=defeitos['Motivo'],
    y=defeitos['Frequ√™ncia'],
    name="Frequ√™ncia",
    marker_color=primary_color
))
fig_pareto.add_trace(go.Scatter(
    x=defeitos['Motivo'],
    y=defeitos['Acumulado %'],
    name="Acumulado %",
    yaxis='y2',
    mode='lines+markers',
    line=dict(color='red', width=2)
))
fig_pareto.update_layout(
    title="Pareto: 80% dos Defeitos v√™m de 20% das Causas",
    yaxis=dict(title="Frequ√™ncia"),
    yaxis2=dict(title="Acumulado %", overlaying='y', side='right'),
    xaxis=dict(title="Motivo do Defeito"),
    showlegend=True
)
st.plotly_chart(fig_pareto, use_container_width=True)

# Diagrama de Ishikawa (Sugest√µes)
# st.markdown("#### üêü Diagrama de Ishikawa (Causa e Efeito)")
# st.write("Poss√≠veis causas para o defeito:")
# causas = {
#     "M√£o de obra": "Treinamento insuficiente do t√©cnico",
#     "M√©todo": "Processo de montagem n√£o padronizado",
#     "Material": "Qualidade da espuma ou tecido",
#     "M√°quina": "Calibra√ß√£o incorreta da prensa",
#     "Meio ambiente": "Umidade no ambiente de armazenamento",
#     "Medida": "Falha no controle de qualidade"
# }
# for categoria, causa in causas.items():
#     st.markdown(f"- **{categoria}**: {causa}")


# === 3.0 ISHIKAWA INTERATIVO (SUNBURST) ===
st.markdown("### üêü Ishikawa Interativo: Cadastre as Causas-Raiz")

# Inicializar session_state para causas
if 'causas_ishikawa' not in st.session_state:
    st.session_state.causas_ishikawa = []

# Formul√°rio para adicionar nova causa
with st.form("form_causa"):
    st.write("Adicione uma causa raiz identificada:")
    categoria = st.selectbox(
        "Categoria (6M)",
        ["M√£o de Obra", "M√©todo", "Material", "M√°quina", "Meio Ambiente", "Medi√ß√£o"]
    )
    causa = st.text_input("Descri√ß√£o da Causa")
    submitted = st.form_submit_button("‚ûï Adicionar Causa")

if submitted and causa.strip() != "":
    st.session_state.causas_ishikawa.append({
        "Categoria": categoria,
        "Causa": causa.strip()
    })
    st.success(f"Causa '{causa}' adicionada em '{categoria}'!")

# Bot√£o para limpar causas (opcional)
if st.session_state.causas_ishikawa and st.button("üóëÔ∏è Limpar todas as causas"):
    st.session_state.causas_ishikawa = []
    st.rerun()

# Exibir lista de causas cadastradas
if st.session_state.causas_ishikawa:
    st.write("### Causas Cadastradas")
    df_causas = pd.DataFrame(st.session_state.causas_ishikawa)
    st.dataframe(df_causas, use_container_width=True)

    # Preparar dados para o sunburst
    # Adicionar n√≥ raiz
    dados_sunburst = [
        {"Categoria": "Problema", "Causa": "Causas do Defeito", "Valor": len(st.session_state.causas_ishikawa)}
    ]
    
    for idx, row in df_causas.iterrows():
        dados_sunburst.append({
            "Categoria": row["Categoria"],
            "Causa": row["Causa"],
            "Valor": 1
        })

    df_sunburst = pd.DataFrame(dados_sunburst)

    # Criar gr√°fico sunburst
    fig_sunburst = px.sunburst(
        df_sunburst,
        path=['Categoria', 'Causa'],
        values='Valor',
        color='Categoria',
        color_discrete_map={
            "M√£o de Obra": "#FF6B35",
            "M√©todo": "#003366",
            "Material": "#2E8B57",
            "M√°quina": "#D4AC0D",
            "Meio Ambiente": "#8E44AD",
            "Medi√ß√£o": "#3498DB",
            "Problema": "#000000"
        },
        title="Ishikawa Interativo (Sunburst) - Causas Cadastradas"
    )
    fig_sunburst.update_layout(height=600)
    st.plotly_chart(fig_sunburst, use_container_width=True)
else:
    st.info("Nenhuma causa cadastrada ainda. Use o formul√°rio acima para come√ßar.")

# === 4. IMPROVE (Melhorar) ===
st.markdown("### üöÄ 4. Improve: Propor Melhorias")

melhorias_sugeridas = [
    f"Padronizar o processo de montagem do {produto_prioritario}",
    f"Treinar a equipe t√©cnica sobre o defeito '{motivo_prioritario}'",
    f"Inspecionar mais rigorosamente a mat√©ria-prima do {produto_prioritario}",
    f"Criar checklist de qualidade para {produto_prioritario}"
]

st.write("‚úÖ **Melhorias sugeridas com base nos dados:**")
for i, melhoria in enumerate(melhorias_sugeridas, 1):
    st.markdown(f"{i}. {melhoria}")

# Campo para usu√°rio adicionar a√ß√µes
st.text_area("üí° Suas a√ß√µes de melhoria", height=150)

# Bot√£o para "Implementar"
if st.button("‚úÖ Implementar Melhorias"):
    st.success("‚úÖ A√ß√µes de melhoria foram registradas e podem ser acompanhadas na pr√≥xima etapa.")

# === 5. CONTROL (Controlar) ===
st.markdown("### üìâ 5. Control: Controlar os Resultados")

st.write("""
Ap√≥s implementar as melhorias, monitore os resultados com indicadores-chave.
""")

# Simula√ß√£o de meta
meta_reducao = st.slider("Meta de redu√ß√£o de defeitos (%)", min_value=10, max_value=80, value=50)
reducao_atual = st.slider("Redu√ß√£o alcan√ßada (%)", min_value=0, max_value=100, value=0)

# Medidor de progresso
progresso = reducao_atual / 100
st.progress(progresso)
st.write(f"Progresso: {reducao_atual}% da meta de {meta_reducao}%")

if reducao_atual >= meta_reducao:
    st.success("‚úÖ Meta atingida! Processo sob controle.")
else:
    st.warning("‚ö†Ô∏è Continue monitorando. Ainda n√£o atingiu a meta.")

# Link para gerar relat√≥rio em pdf
st.markdown("### üì• Gerar Relat√≥rio Completo")
st.download_button(
    label="üìÑ Baixar Relat√≥rio DMAIC",
    data=df_dmaic.to_csv(index=False).encode('utf-8'),
    file_name="relatorio_dmaic.csv",
    mime="text/csv"
)
# RODAP√â da pag. 
st.markdown("---")
st.markdown(f"""
<div style='text-align: center; color: #666; font-size: 12px; margin-top: 20px;'>
    Dashboard gerado em {datetime.now().strftime('%d/%m/%Y √†s %H:%M')} | ¬© 2025 Colch√µes BonSono. Todos os direitos reservados.
</div>
""", unsafe_allow_html=True)
